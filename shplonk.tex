% !tex ts-program = pdflatex
% !tex encoding = utf-8 unicode

% this is a simple template for a latex document using the "article" class.
% see "book", "report", "letter" for other types of document.

\documentclass[11pt]{article} % use larger type; default would be 10pt
\usepackage[
    type={CC},
    modifier={by-nc-sa},
    version={3.0},
]{doclicense}

\usepackage{fullpage}

\usepackage[utf8]{inputenc} % set input encoding (not needed with xelatex)
\usepackage[strict]{changepage}

    %%% examples of article customizations
    % these packages are optional, depending whether you want the features they provide.
    % see the latex companion or other references for full information.


    %%% page dimensions
\usepackage{geometry} % to change the page dimensions
\geometry{a4paper} % or letterpaper (us) or a5paper or....
    % \geometry{margin=2in} % for example, change the margins to 2 inches all round
    % \geometry{landscape} % set up the page for landscape
    %   read geometry.pdf for detailed page layout information
 \usepackage{numdef}

\usepackage{graphicx} % support the \includegraphics command and options
    % some of the article customisations are relevant for this class
\usepackage{amsmath,amsthm}
\usepackage{amsfonts} % math fonts such as \mathbb{}
\usepackage{amssymb} % \therefore
\usepackage{hyperref}
\usepackage{cryptocode}
\usepackage{framed}
    % \usepackage[parfill]{parskip} % activate to begin paragraphs with an empty line rather than an indent

    %%% packages
\usepackage{booktabs} % for much better looking tables
\usepackage{array} % for better arrays (eg matrices) in maths
\usepackage{paralist} % very flexible & customisable lists (eg. Enumerate/itemize, etc.)
\usepackage{verbatim} % adds environment for commenting out blocks of text & for better verbatim
\usepackage{subfig} % make it possible to include more than one captioned figure/table in a single float
    % % these packages are all incorporated in the memoir class to one degree or another...
\usepackage{mathrsfs}
\usepackage{booktabs}
\usepackage{makecell}
\usepackage{adjustbox}

\usepackage{pgfplots}

\renewcommand\theadalign{bc}
\renewcommand\theadfont{\bfseries}
\renewcommand\theadgape{\Gape[4pt]}

    %%% headers & footers
\usepackage{fancyhdr} % this should be set after setting up the page geometry
\pagestyle{fancy} % options: empty , plain , fancy
\renewcommand{\headrulewidth}{0pt} % customise the layout...
\lhead{}\chead{}\rhead{}
\lfoot{}\cfoot{\thepage}\rfoot{}


    %%% section title appearance
\usepackage{sectsty}
\allsectionsfont{\sffamily\mdseries\upshape} % (see the fntguide.pdf for font help)
    % (this matches context defaults)

    %%% toc (table of contents) appearance
\usepackage[nottoc,notlof,notlot]{tocbibind} % put the bibliography in the toc
\usepackage[titles,subfigure]{tocloft} % alter the style of the table of contents
\renewcommand{\cftsecfont}{\rmfamily\mdseries\upshape}
\renewcommand{\cftsecpagefont}{\rmfamily\mdseries\upshape} % no bold!

    %%% end article customizations
    \newcommand{\code}[1]{\texttt{#1}}
\newcommand\tstrut{\rule{0pt}{2.6ex}}         % = `top' strut
\newcommand\bstrut{\rule[-0.9ex]{0pt}{0pt}}   % = `bottom' strut
\newcommand{\bgamma}{\boldsymbol{\gamma}}
\newcommand{\bsigma}{\boldsymbol{\sigma}}
%%% the "real" document content comes below...
%\newcommand{\papertitle}{$\mathsf{Maitreya}$: Improved Prover Efficiency in Fully Succinct Universal zk-SNARKs through Permutation Arguments for Multiplicative Subgroups}
\newcommand{\papertitle}{An efficient polynomial commitment scheme for multiple points and polynomials}
%\newcommand{\authorname}}
\newcommand{\company}{}
\title{ \bf \papertitle \\[0.72cm]}
\author{Justin Drake \\ \tt{Ethereum Foundation} \and  Ariel Gabizon\\ \tt{AZTEC Protocol}  \and Zachary J. Williamson\\ \tt{AZTEC Protocol}}

% 	\large{\authorname} \\[0.5cm] \large{\company}
% 	\\ {DRAFT}
%}
    %\date{} % activate to display a given date or no date (if empty),

           % otherwise the current date is printed

\ProvidesPackage{numdef}

%% Ariel Macros:
\num\newcommand{\G1}{\ensuremath{{\mathbb G}_1}\xspace}
\newcommand{\Gi}{\ensuremath{{\mathbb G}_i}\xspace}
%\newcommand{\G}{\ensuremath{{\mathbb G}}\xspace}
\newcommand{\Gstar}{\ensuremath{{\mathbb G}^*}\xspace}
\newcommand{\x}{\ensuremath{\mathbf{x}}\xspace}
\newcommand{\z}{\ensuremath{\mathbf{z}}\xspace}
\newcommand{\X}{\ensuremath{\mathbf{X}}\xspace}

\num\newcommand{\G2}{\ensuremath{{\mathbb G}_2}\xspace}
%\num\newcommand{\G11}{\ensuremath{\G1\setminus \set{0} }\xspace}
%\num\newcommand{\G21}{\ensuremath{\G2\setminus \set{0} }\xspace}
\newcommand{\grouppair}{\ensuremath{G^*}\xspace}
\newcommand{\prvperm}{\ensuremath{\mathrm{P_{\mathsf{\sigma}}}}\xspace}
\newcommand{\verperm}{\ensuremath{\mathrm{V_{\mathsf{\sigma}}}}\xspace}

\newcommand{\Gt}{\ensuremath{{\mathbb G}_t}\xspace}
\newcommand{\F}{\ensuremath{\mathbb F}\xspace}
\newcommand{\Fstar}{\ensuremath{\mathbb F^*}\xspace}

\newcommand{\help}[1]{$#1$-helper\xspace}
\newcommand{\randompair}[1]{\ensuremath{\mathsf{randomPair}(#1)}\xspace}
\newcommand{\pair}[1]{$#1$-pair\xspace}
\newcommand{\pairs}[1]{$#1$-pairs\xspace}

\newcommand{\pairone}[1]{\G1-$#1$-pair\xspace}
\newcommand{\pairtwo}[1]{\G2-$#1$-pair\xspace}
\newcommand{\sameratio}[2]{\ensuremath{\mathsf{SameRatio}(#1,#2)}\xspace}
\newcommand{\vecc}[2]{\ensuremath{(#1)_{#2}}\xspace}
\newcommand{\players}{\ensuremath{[n]}\xspace}
\newcommand{\adv}{\ensuremath{\mathcal A}\xspace}
\newcommand{\advprime}{\ensuremath{{\mathcal A}'}\xspace}
\newcommand{\extprime}{\ensuremath{E'}\xspace}
\newcommand{\advrand}{\ensuremath{\mathsf{rand}_{\adv}}\xspace}
\num\newcommand{\srs1}{\ensuremath{\mathsf{srs_1}}\xspace}
\num\newcommand{\srs2}{\ensuremath{\mathsf{srs_2}}\xspace}
\num\newcommand{\srs0}{\ensuremath{\mathsf{srs}}\xspace}
\newcommand{\srsi}{\ensuremath{\mathsf{srs_i}}\xspace}
\newcommand{\com}{\ensuremath{\mathsf{com}}\xspace}
\newcommand{\comperm}{\ensuremath{\mathsf{com_{\sigma}}}\xspace}
\newcommand{\cm}{\ensuremath{\mathsf{cm}}\xspace}
\newcommand{\cmsig}{\ensuremath{\mathsf{cm_\sigma}}\xspace}
\newcommand{\open}{\ensuremath{\mathsf{open}}\xspace}
\newcommand{\openperm}{\ensuremath{\mathsf{open_{\sigma}}}\xspace}
\newcommand{\sigof}[1]{\ensuremath{\sigma(#1)}\xspace}
\newcommand{\proverexp}{\ensuremath{\mathsf{e}}\xspace}
\newcommand{\reducedelems}{\ensuremath{\mathsf{r}}\xspace}

\newcommand{\ci}{\ensuremath{\mathrm{CI}}\xspace}
\renewcommand{\deg}{\ensuremath{\mathrm{deg}}\xspace}
\newcommand{\pairvec}[1]{$#1$-vector\xspace}
\newcommand{\Fq}{\ensuremath{\mathbb{F}_q}\xspace}
\newcommand{\randpair}[1]{\ensuremath{\mathsf{rp}_{#1}}\xspace}
\newcommand{\randpairone}[1]{\ensuremath{\mathsf{rp}_{#1}^{1}}\xspace}
\newcommand{\abase}{\ensuremath{A_{\mathrm{\mathbf{0}}}}\xspace}
\newcommand{\bbase}{\ensuremath{B_{\mathrm{\mathbf{0}}}}\xspace}
\newcommand{\cbase}{\ensuremath{C_{\mathrm{\mathbf{0}}}}\xspace}

\newcommand{\amid}{\ensuremath{A_{\mathrm{mid}}}\xspace}
\newcommand{\bmid}{\ensuremath{B_{\mathrm{mid}}}\xspace}
\newcommand{\cmid}{\ensuremath{C_{\mathrm{mid}}}\xspace}

\newcommand{\negl}{\ensuremath{\mathsf{negl}(\lambda)}\xspace}
\newcommand{\randpairtwo}[1]{\ensuremath{\mathsf{rp_{#1}^2}}\xspace}%the randpair in G2
\newcommand{\nilp}{\ensuremath{\mathscr N}\xspace}
\newcommand{\groupgen}{\ensuremath{\mathscr G}\xspace}
\newcommand{\qap}{\ensuremath{\mathscr Q}\xspace}
\newcommand{\polprot}[4]{$(#1,#2,#3,#4)$-polynomial protocol}
\newcommand{\rangedprot}[5]{$#5$-ranged $(#1,#2,#3,#4)$-polynomial protocol}

\newcommand{\rej}{\ensuremath{\mathsf{rej}}\xspace}
\newcommand{\acc}{\ensuremath{\mathsf{acc}}\xspace}
\newcommand{\res}{\ensuremath{\mathsf{res}}\xspace}
\newcommand{\sha}[1]{\ensuremath{\mathsf{COMMIT}(#1)}\xspace}
 \newcommand{\shaa}{\ensuremath{\mathsf{COMMIT}}\xspace}
 \newcommand{\comm}[1]{\ensuremath{\mathsf{comm}_{#1}}\xspace}
 \newcommand{\defeq}{:=}

\newcommand{\B}{\ensuremath{\vec{B}}\xspace}
\newcommand{\dom}{\ensuremath{H}\xspace}
\newcommand{\C}{\ensuremath{\vec{C}}\xspace}
\newcommand{\Btwo}{\ensuremath{\vec{B_2}}\xspace}
\newcommand{\treevecsimp}{\ensuremath{(\tau,\rho_A,\rho_A \rho_B,\rho_A\alpha_A,\rho_A\rho_B\alpha_B, \rho_A\rho_B\alpha_C,\beta,\beta\gamma)}\xspace}% The sets of elements used in simplifed relation tree in main text body
\newcommand{\rcptc}{random-coefficient subprotocol\xspace}
\newcommand{\rcptcparams}[2]{\ensuremath{\mathrm{RCPC}(#1,#2)}\xspace}
\newcommand{\verifyrcptcparams}[2]{\ensuremath{\mathrm{\mathsf{verify}RCPC}(#1,#2)}\xspace}
\newcommand{\randadv}{\ensuremath{\mathsf{rand}_{\adv}}\xspace}
 \num\newcommand{\ex1}[1]{\ensuremath{ #1\cdot g_1}\xspace}
 \num\newcommand{\ex2}[1]{\ensuremath{#1\cdot g_2}\xspace}
 \newcommand{\pr}{\mathrm{Pr}}
 \newcommand{\powervec}[2]{\ensuremath{(1,#1,#1^{2},\ldots,#1^{#2})}\xspace}
 \newcommand{\partition}{\ensuremath{{\mathcal T}}\xspace}
 \newcommand{\partof}[1]{\ensuremath{{\partition_{#1}}}\xspace}
\num\newcommand{\out1}[1]{\ensuremath{\ex1{\powervec{#1}{d}}}\xspace}
\num\newcommand{\out2}[1]{\ensuremath{\ex2{\powervec{#1}{d}}}\xspace}
 \newcommand{\nizk}[2]{\ensuremath{\mathrm{NIZK}(#1,#2)}\xspace}% #2 is the hash concatenation input
 \newcommand{\verifynizk}[3]{\ensuremath{\mathrm{VERIFY\mhyphen NIZK}(#1,#2,#3)}\xspace}
\newcommand{\protver}{protocol verifier\xspace}
\newcommand{\mulgroup}{\ensuremath{\F^*}\xspace}
\newcommand{\lag}[1]{\ensuremath{L_{#1}}\xspace}
\newcommand{\sett}[2]{\ensuremath{\set{#1}_{#2}}\xspace}
\newcommand{\omegaprod}{\ensuremath{\alpha_{\omega}}\xspace}
\newcommand{\lagvec}[1]{\ensuremath{\mathrm{LAG}_{#1}}\xspace}
\newcommand{\trapdoor}{\ensuremath{r}}
\newcommand{\trapdoorext}{\ensuremath{r_{\mathrm{ext}}}\xspace}
\newcommand{\trapdoorsim}{\ensuremath{r_{\mathrm{sim}}}\xspace}
\renewcommand{\mod}{\ensuremath{\;\mathrm{mod}\;}}
\newcommand{\hsub}{\ensuremath{H^*}\xspace}
\num\newcommand{\enc1}[1]{\ensuremath{\left[#1\right]_1}\xspace}
\newcommand{\enci}[1]{\ensuremath{\left[#1\right]_i}\xspace}
\num\newcommand{\enc2}[1]{\ensuremath{\left[#1\right]_2}\xspace}
\newcommand{\gen}{\ensuremath{\mathsf{gen}}\xspace}
\newcommand{\prv}{\ensuremath{\mathsf{\mathbf{P}}}\xspace}
\newcommand{\prvpoly}{\ensuremath{\mathrm{P_{\mathsf{poly}}}}\xspace}
\newcommand{\prvpc}{\ensuremath{\mathrm{P_{\mathsf{PC}}}}\xspace}
\newcommand{\verpoly}{\ensuremath{\mathrm{V_{\mathsf{poly}}}}\xspace}
\newcommand{\verpc}{\ensuremath{\mathrm{V_{\mathsf{PC}}}}\xspace}
\newcommand{\ideal}{\ensuremath{\mathcal{I}}\xspace}
\newcommand{\prf}{\ensuremath{\pi}\xspace}
\newcommand{\simprv}{\ensuremath{\mathrm{P^{sim}}}\xspace}

%\newcommand{\enc}[1]{\ensuremath{\left[#1\right]}\xspace}
%\num\newcommand{\G0}{\ensuremath{\mathbf{G}}\xspace}
\newcommand{\GG}{\ensuremath{\mathbf{G^*}}\xspace}  % would have liked to call this G01 but problem with name
\num\newcommand{\g0}{\ensuremath{\mathbf{g}}\xspace}
\newcommand{\inst}{\ensuremath{\phi}\xspace}
\newcommand{\inp}{\ensuremath{\mathsf{x}}\xspace}
\newcommand{\wit}{\ensuremath{\omega}\xspace}
\newcommand{\ver}{\ensuremath{\mathsf{\mathbf{V}}}\xspace}
\newcommand{\per}{\ensuremath{\mathsf{\mathbf{P}}}\xspace}
\newcommand{\sonic}{\ensuremath{\mathsf{Sonic}}\xspace}
\newcommand{\aurora}{\ensuremath{\mathsf{Aurora}}\xspace}
\newcommand{\auroralight}{\ensuremath{\mathsf{Auroralight}}\xspace}
\newcommand{\groth}{\ensuremath{\mathsf{Groth'16}}\xspace}
\newcommand{\kate}{\ensuremath{\mathsf{KZG}}\xspace}
\newcommand{\rel}{\ensuremath{\mathcal{R}}\xspace}
\newcommand{\ext}{\ensuremath{E}\xspace}
\newcommand{\params}{\ensuremath{\mathsf{params}_{\inst}}\xspace}
\newcommand{\protparams}{\ensuremath{\mathsf{params}_{\inst}^\advv}\xspace}
\num\newcommand{\p1}{\ensuremath{P_1}\xspace}
\newcommand{\advv}{\ensuremath{ {\mathcal A}^{\mathbf{*}}}\xspace} % the adversary that uses protocol adversary as black box
\newcommand{\crs}{\ensuremath{\sigma}\xspace}
%\num\newcommand{\crs1}{\ensuremath{\mathrm{\sigma}_1}\xspace}
%\num\newcommand{\crs2}{\ensuremath{\mathrm{\sigma}_2}\xspace}
\newcommand{\set}[1]{\ensuremath{\left\{#1\right\}}\xspace}
\newcommand{\hgen}{\ensuremath{\mathbf{g}}\xspace}
\renewcommand{\sim}{\ensuremath{\mathsf{sim}}\xspace}%the distribution of messages when \advv simulates message of \p1
\newcommand{\real}{\ensuremath{\mathsf{real}}\xspace}%the distribution of messages when \p1 is honest and \adv controls rest of players
 \newcommand{\koevec}[2]{\ensuremath{(1,#1,\ldots,#1^{#2},\alpha,\alpha #1,\ldots,\alpha #1^{#2})}\xspace}
\newcommand{\mida}{\ensuremath{A_{\mathrm{mid}}}\xspace}
\newcommand{\midb}{\ensuremath{B_{\mathrm{mid}}}\xspace}
\newcommand{\midc}{\ensuremath{C_{\mathrm{mid}}}\xspace}
\newcommand{\chal}{\ensuremath{\mathsf{challenge}}\xspace}
\newcommand{\attackparams}{\ensuremath{\mathsf{params^{pin}}}\xspace}
\newcommand{\pk}{\ensuremath{\mathsf{pk}}\xspace}
\newcommand{\attackdist}[2]{\ensuremath{AD_{#1}}\xspace}
\renewcommand{\neg}{\ensuremath{\mathsf{negl}(\lambda)}\xspace}
\newcommand{\ro}{\ensuremath{{\mathcal R}}\xspace}
\newcommand{\elements}[1]{\ensuremath{\mathsf{elements}_{#1}}\xspace}
 \num\newcommand{\elmpowers1}[1]{\ensuremath{\mathrm{\mathsf{e}}^1_{#1}}\xspace}
 \num\newcommand{\elmpowers2}[1]{\ensuremath{\mathrm{\mathsf{e}}^2_{#1}}\xspace}
\newcommand{\elempowrs}[1]{\ensuremath{\mathsf{e}_{#1}}\xspace}
 \newcommand{\secrets}{\ensuremath{\mathsf{secrets}}\xspace}
 \newcommand{\polysofdeg}[1]{\ensuremath{\F_{< #1}[X]}\xspace}
 \newcommand{\bivar}[1]{\ensuremath{\F_{< #1}[X,Y]}\xspace}
 \newcommand{\sig}{\ensuremath{\mathscr{S}}\xspace}
 \newcommand{\prot}{\ensuremath{\mathscr{P}}\xspace}
 \newcommand{\PCscheme}{\ensuremath{\mathscr{S}}\xspace}
 \newcommand{\protprime}{\ensuremath{\mathscr{P^*}}\xspace}
 \newcommand{\sigprv}{\ensuremath{\mathsf{P_{sc}}}\xspace}
 \newcommand{\sigver}{\ensuremath{\mathsf{V_{sc}}}\xspace}
 \newcommand{\sigpoly}{\ensuremath{\mathsf{S_{\sigma}}}\xspace}
 \newcommand{\idpoly}{\ensuremath{\mathsf{S_{ID}}}\xspace}
\newcommand{\idpolyevala}{\ensuremath{\mathsf{\bar{s}_{ID1}}}\xspace}
\newcommand{\sigpolyevala}{\ensuremath{\mathsf{\bar{s}_{\sigma1}}}\xspace}
\newcommand{\sigpolyevalb}{\ensuremath{\mathsf{\bar{s}_{\sigma2}}}\xspace}
\newcommand{\bctv}{\ensuremath{\mathsf{BCTV}}\xspace}
\newcommand{\PI}{\ensuremath{\mathsf{PI}}\xspace}
\newcommand{\PIb}{\ensuremath{\mathsf{PI_B}}\xspace}
\newcommand{\PIc}{\ensuremath{\mathsf{PI_C}}\xspace}
\newcommand{\dl}[1]{\ensuremath{\widehat{#1}}\xspace}
\newcommand{\obgen}{\ensuremath{\mathcal O}\xspace}
\newcommand{\PC}{\ensuremath{\mathscr{P}}\xspace}
\newcommand{\permscheme}{\ensuremath{\sigma_\mathscr{P}}\xspace}


\newcommand{\selleft}{\ensuremath{\mathbf{q_L}}\xspace}
\newcommand{\selright}{\ensuremath{\mathbf{q_R}}\xspace}
\newcommand{\selout}{\ensuremath{\mathbf{q_O}}\xspace}
\newcommand{\selmult}{\ensuremath{\mathbf{q_M}}\xspace}
\newcommand{\selconst}{\ensuremath{\mathbf{q_C}}\xspace}
\newcommand{\selectors}{\ensuremath{\mathcal{Q}}\xspace}
\newcommand{\lvar}{\ensuremath{\mathbf{a}}\xspace}
\newcommand{\vars}{\ensuremath{\mathcal{V}}\xspace}
\newcommand{\rvar}{\ensuremath{\mathbf{b}}\xspace}
\newcommand{\ovar}{\ensuremath{\mathbf{c}}\xspace}
\newcommand{\pubvars}{\ensuremath{\mathcal{I}}\xspace}
\newcommand{\assignment}{\ensuremath{\mathbf{x}}\xspace}
\newcommand{\constsystem}{\ensuremath{\mathscr{C}}\xspace}
\newcommand{\relof}[1]{\ensuremath{\rel_{#1}}\xspace}
\newcommand{\pubinppoly}{\ensuremath{\mathsf{PI}}\xspace}
\newcommand{\sumi}[1]{\sum_{i\in[#1]}}
\newcommand{\summ}[1]{\sum_{i\in[#1]}}
\newcommand{\sumj}[1]{\sum_{j\in[#1]}}
\newcommand{\ZeroH}{\ensuremath{Z_{H}} \xspace}
\newcommand{\lpoly}{\ensuremath{\mathsf{a}}\xspace}
\newcommand{\rpoly}{\ensuremath{\mathsf{b}}\xspace}
\newcommand{\opoly}{\ensuremath{\mathsf{c}}\xspace}
\newcommand{\idpermpoly}{\ensuremath{\mathsf{z}}\xspace}
\newcommand{\lagrangepoly}{\ensuremath{\mathsf{L}}\xspace}
\newcommand{\zeropoly}{\ensuremath{\mathsf{\ZeroH}}\xspace}
\newcommand{\selmultpoly}{\ensuremath{\mathsf{q_M}}\xspace}
\newcommand{\selleftpoly}{\ensuremath{\mathsf{q_L}}\xspace}
\newcommand{\selrightpoly}{\ensuremath{\mathsf{q_R}}\xspace}
\newcommand{\seloutpoly}{\ensuremath{\mathsf{q_O}}\xspace}
\newcommand{\selconstpoly}{\ensuremath{\mathsf{q_C}}\xspace}
\newcommand{\idcomm}{\ensuremath{[s_{\mathsf{ID1}}]_1}\xspace}
\newcommand{\sigcomma}{\ensuremath{[s_{\mathsf{\sigma1}}]_1}\xspace}
\newcommand{\sigcommb}{\ensuremath{[s_{\mathsf{\sigma2}}]_1}\xspace}
\newcommand{\sigcommc}{\ensuremath{[s_{\mathsf{\sigma3}}]_1}\xspace}
\newcommand{\selleftcomm}{\ensuremath{[q_\mathsf{L}]_1}\xspace}
\newcommand{\selrightcomm}{\ensuremath{[q_\mathsf{R}]_1}\xspace}
\newcommand{\seloutcomm}{\ensuremath{[q_\mathsf{O}]_1}\xspace}
\newcommand{\selconstcomm}{\ensuremath{[q_\mathsf{C}]_1}\xspace}
\newcommand{\selmultcomm}{\ensuremath{[q_\mathsf{M}]_1}\xspace}

\newcommand{\multlinecomment}[1]{\directlua{-- #1}}


\newtheorem{lemma}{Lemma}[section]
\newtheorem{thm}[lemma]{Theorem}
\newtheorem{dfn}[lemma]{Definition}
\newtheorem{remark}[lemma]{Remark}

\newtheorem{claim}[lemma]{Claim}
\newtheorem{corollary}[lemma]{Corollary}
\newcommand{\Z}{\mathbb{Z}}
\newcommand{\R}{\mathcal{R}}
\newcommand{\crct}{\ensuremath{\mathsf{C}}\xspace}
\newcommand{\A}{\mathcal{A}}
%\newcommand{\G}{\mathcal{G}}
\newcommand{\Gr}{\mathbb{G}}
%\newcommand{\com}{\textsf{com}}  Ariel defined equivalent that also works in math mode
\newcommand{\cgen}{\text{cgen}}
\newcommand{\poly}{\ensuremath{\mathsf{poly(\lambda)}}\xspace}
\newcommand{\snark}{\ensuremath{\mathsf{snark(\lambda)}}\xspace}
\newcommand{\grandprod}{\mathsf{prod}}
\newcommand{\perm}{\mathsf{perm}}
%\newcommand{\open}{\mathsf{open}}
\newcommand{\update}{\mathsf{update}}
\newcommand{\Prove}{\mathcal{P}}
\newcommand{\Verify}{\mathcal{V}}
\newcommand{\Extract}{\mathcal{E}}
\newcommand{\Simulate}{\mathcal{S}}
\newcommand{\Unique}{\mathcal{U}}
\newcommand{\Rpoly}{\R{\poly}}
\newcommand{\Ppoly}{\Prove{\poly}}
\newcommand{\Vpoly}{\Verify{\poly}}
\newcommand{\Psnark}{\Prove{\snark}}
\newcommand{\Vsnark}{\Verify{\snark}}
\newcommand{\Rprod}{\R{\grandprod}}
\newcommand{\Pprod}{\Prove{\grandprod}}
\newcommand{\Vprod}{\Verify{\grandprod}}
\newcommand{\Rperm}{\R{\perm}}
\newcommand{\Pperm}{\Prove{\perm}}
\newcommand{\Vperm}{\Verify{\perm}}
% \newcommand{\zw}[1]{{\textcolor{magenta}{Zac:#1}}}
% \newcommand{\ag}[1]{{\textcolor{blue}{\emph{Ariel:#1}}}}
\newcommand{\prob}{\ensuremath{\mathrm{Pr}}\xspace}
\newcommand{\extprot}{\ensuremath{E_{\prot}}\xspace}
\newcommand{\extpc}{\ensuremath{E_{\PCscheme}}\xspace}
\newcommand{\advpc}{\ensuremath{\mathcal A_{\PCscheme}}\xspace}
\newcommand{\advprot}{\ensuremath{\mathcal A_{\prot}}\xspace}
\newcommand{\protmany}{\ensuremath{ {\prot}_k}\xspace}

\usepackage{pifont}% http://ctan.org/pkg/pifont
\newcommand{\cmark}{\ding{51}}%
\newcommand{\xmark}{\ding{55}}%
\newcommand{\plonk}{\ensuremath{\mathtt{PLONK}}\xspace}
\newcommand{\shplonk}{\ensuremath{\mathtt{SHPLONK}}\xspace}
\newcommand{\marlin}{\ensuremath{\mathsf{Marlin}}\xspace}
\newcommand{\fractal}{\ensuremath{\mathsf{Fractal}}\xspace}
\newcommand{\Rsnark}{\R{\snark}}
\begin{document}
    \maketitle

\begin{abstract}
We present an enhanced version of the Kate, Zaverucha and Goldberg polynomial commitment scheme \cite{kate} where a single group element can be an opening proof for multiple polynomials each evaluated at a different arbitrary subset of points.



As a sample application we ``plug in'' this scheme into the \plonk proving system\cite{plonk} to obtain improved proof size and prover run time at the expense of additional verifier \G2 operations and pairings,  and additional \G2 SRS elements.
\end{abstract}

\section{Introduction}

Polynomial commitment schemes (PCS) are an important primitive in arguably all\footnote{While QAP-based proving systems like \cite{pinocchio,groth16} are not traditionally formulated as using a PCS, they can be interpreted as using a PCS that also forces the committed polynomial to be in a certain subspace. This is related to the linear interactive proof framework of  \cite{bciop}.} practical succinct proving systems (see \cite{marlin,plonk,supersonic} for formalizations of their role).  They can ``force'' a prover to answer verifier queries according to a fixed polynomial of bounded degree.

The use of a PCS typically starts by an initial prover message $\com(f)$ corresponding to the commitment to a polynomial $f$. Then, in the more straightforward use of this primitive, whenever the prover sends a value $s\in \F$ which is allegedly the value $f(z)$ for $z$ known to the verifier, the prover will send a corresponding ``opening proof'' $\pi$ that this is indeed the case. When a PCS is used in this way for several polynomials and several evaluation points, prover run time and proof length will increase with each of these opening proofs.



\subsection{Previous work and our results}

We take the PCS of Kate, Zaverucha and Goldberg \cite{kate} as our starting point. Their scheme is pairing-based and an opening proof $\pi$ consists of a single $\G1$ group element. We ask whether we can get a variant of this scheme where a single $\G1$ element can prove correctness of multiple polynomial evaluations.

Several works \cite{sonic,auroralight,marlin,plonk} (starting from \cite{sonic}) have noticed that it is possible to modify the PCS of \cite{kate} in the random oracle model to allow for one opening proof for several polynomials \emph{at the same point $z\in \F$} .
\cite{kate} give in their paper a less known version of their scheme allowing for one opening proof for one polynomial at several evaluation points.



In this paper, we give two PCS schemes for multiple evaluation points and polynomials.
\begin{itemize}
 \item In our first scheme the opening proof is only a single \G1 element, but verifier operations are considerably heavier than previous variants of \cite{kate} when the number of distinct evaluation points is large (cf. Lemma \ref{lem:multikate}).
\item In our second scheme the opening proof is 2 \G1 elements, and the verifier complexity is slightly better than previous multipoint variants of \cite{kate} (cf. Lemma \ref{lem:multikateG1}).
 \end{itemize}

We compare the performance of our PCSs to a more straightforward batched version of the \cite{kate} scheme as in \cite{plonk}.
For simplicity, we look at the restricted case where we want to open $t$ polynomials all with the same degree bound $n$, each at one \emph{distinct} point. See Lemma \ref{lem:multikate} for the more detailed efficiency properties in the general case (where each polynomial is opened at a subset of points, and the subsets may repeat).
\begin{table}[!htbp]
	\caption{Comparison of opening complexity for $t$ polynomials on $t$ distinct points. In prover/verifier work columns \Gi means scalar multiplication in \Gi, \F means addition or multiplication in \F, and \textbf{P} means pairing. }
	\centering
\begin{adjustbox}{width=1\textwidth}
	\begin{tabular}{l|l|l|l|l}
	& \thead{SRS size} & \thead{prover work} & \thead{proof\\ length} & \thead{verifier work} \\ \hline
		\kate as in \cite{plonk}
		         & $n$ \G1, $2$ \G2  & $t\cdot n$ \G1, $O(t\cdot n\log n)$ \F &   $t$ \G1 &  $3t-2$ \G1, $2$ \textbf{P}\\ \hline
		This work, ver. 1     & $n$ \G1, $t+1$ \G2 &   $n$ \G1, $O(t\cdot n + n\log n)$ \F  & $1$ \G1 & $t-1$ \G1, $2t$ \G2, $t+1$ \textbf{P}   \\ \hline
	This work, ver. 2     & $n$ \G1, $2$ \G2 &   $2n$ \G1, $O(t\cdot n + n\log n)$ \F  & $2$ \G1 & $2t+1$ \G1, $2$ \textbf{P}   \\ \hline

	\end{tabular}
\end{adjustbox}
\label{table:prover-work}
\end{table}



\paragraph{Application to \plonk:}


The \plonk proving system \cite{plonk}  allows generating proofs of knowledge for assignments
to fan-in two arithmetic circuits with a universal and updatable SRS (see the paragraph on this topic in Section \ref{sec:terminology}). Most of the prover computation involves committing to several polynomials and opening them at two distinct evaluation points. Plugging in our PCS to \plonk allows saving in proof length and prover work related to the opening proof of the second evaluation point (we do not give full details, but all that is needed is repreating the transformation of Lemma 4.7 in \cite{plonk} using the PCS of Lemma \ref{lem:multikate} instead of the PCS used there to obtain the new result).

We compare the \plonk scheme when using the  \cite{kate}-based PCS in \cite{plonk} and the first PCS of this paper in Table \ref{table:plonk}. As in \cite{plonk} we present two versions of \plonk where one optimizes fast proving, and the other small proof length.

\begin{table}[!htbp]
	\caption{Comparison of \plonk efficiency for fan-in two circuit with $n$  gates.}
	\centering
\begin{adjustbox}{width=1\textwidth}
	\begin{tabular}{l|l|l|l|l}
	 & \thead{SRS size} & \thead{prover \\ group exponentations} & \thead{proof\\ length} & verifier work \\ \hline
		\cite{plonk} (fast) &  $n$ \G1, $2$ \G2  & $9n$ \G1 exp   & $9$ \G1, $7$ \F  &   $18$ \G1, $2$ \textbf{P} \\ \hline
		This work (fast)    &$n$ \G1, $3$ \G2 &  $8n$ \G1 exp    & $8$ \G1 $7$ \F &   $18$ \G1, $4$ \G2, $3$ \textbf{P} \\ \hline
		\cite{plonk} (small) &  $3n$ \G1, $2$ \G2  & $11n$ \G1 exp   & $7$ \G1, $7$ \F  &   $16$ \G1, $2$ \textbf{P} \\ \hline
		This work (small)    &$3n$ \G1, $3$ \G2 &  $10n$ \G1 exp    & $6$ \G1 $7$ \F &   $16$ \G1, $4$ \G2, $3$ \textbf{P} \\ \hline

		\end{tabular}
\end{adjustbox}
\label{table:plonk}
\end{table}

\paragraph{\shplonk?}
Our second PCS does not give interesting tradeoffs for \plonk as two evaluation points are not enough for its advantages to ``kick in''. However, in a scenario where constraints between \emph{more than two} evaluation points are used, e.g. \cite{slonk}, the advantages of both of our new schemes will become more prominent. Thus, the PCSs of this paper encourage designing constraint systems using multiple SHifts and Permutations over Largange bases for Oecumenical Noninteractive arguments of Knowledge.
\section{Preliminaries}


\subsection{Terminology and conventions}\label{sec:terminology}
We assume our field \F is of prime order.
%We assume we have a
%multiplicative subgroup $H \subset F$ of size $|H| = n$ where $n$ is the number of constraints in our R1CS.
%and denote for simplicity the elements of H as H = {1, . . . , m}.
%We assume the number of private variables n is equal to m.
We denote by \polysofdeg{d} the set of univariate polynomials over \F of degree smaller than d.
In expressions involving both polynomials and constants, we will write $f(X)$ instead of $f$ for
to help distinguish the two; but in contexts where it is clear $f$ is a polynomial, we will simply write $f$ for brevity.

We assume all algorithms described receive as an implicit parameter the security parameter $\lambda$.

Whenever we use the term “efficient”, we mean an algorithm running in time \poly. Furthermore,
we assume an “object generator” \obgen that is run with input $\lambda$ before all protocols, and returns all fields and groups used. Specifically, in our protocol $\obgen(\lambda) = (\F, \G1, \G2, \Gt, e, g_1, g_2,g_t)$ where
\begin{itemize}
\item \F is a prime field of super-polynomial size $r = \lambda^{\omega(1)}$
.
\item $\G1,\G2,\Gt$ are all groups of size $r$, and $e$ is an efficiently computable non-degenerate pairing
$e : \G1 \times \G2 \to \Gt$.
\item $g_1,g_2$ are uniformly chosen generators such that $e(g_1, g_2) = g_t$.
\end{itemize}
We usually let the $\lambda$ parameter be implicit, i.e.\ write \F instead of $\F(\lambda)$.
We write \G1 and \G2 additively. We use the notations $\enc1{x}\defeq x\cdot g_1$ and $\enc2{x}\defeq x\cdot g_2$.

We often denote by $[n]$ the integers \set{1,\ldots,n}.
% For example, when we refer below to the field $\F$, it is in fact a function $\F(\lambda)$ of $\lambda$, and part of
% the output of $\obgen(\lambda)$.
We use the acronym e.w.p for ``except with probability''; i.e. e.w.p $\gamma$ means with probability \emph{at least} $1-\gamma$.

\paragraph{Universal SRS-based public-coin protocols}
We describe public-coin (meaning the verifier messages are uniformly chosen) interactive protocols between a prover and verifier; when deriving results for non-interactive protocols, we implicitly assume we can get a proof length equal to the total communication of the prover, using the Fiat-Shamir transform/a random oracle. Using this reduction between interactive and non-interactive protocols, we can refer to the ``proof length'' of an interactive protocol.

We allow our protocols to have access to a structured reference string (SRS) that can be derived in deterministic \poly-time from an ``SRS of monomials'' of the form
\sett{\enc1{x^i}}{a\leq i \leq b}, \sett{\enc2{x^i}}{c\leq i \leq d}, for uniform $x\in \F$,
and some integers $a,b,c,d$ with absolute value bounded by \poly.
It then follows from Bowe et al. \cite{SecondMPC} that the required SRS can be derived in a universal and updatable setup requiring only one honest participant; in the sense that an adversary controlling all but one of the participants in the setup does not gain more than a \negl advantage in its probability of producing a proof of any statement.

For notational simplicity, we sometimes use the SRS \srs0 as an implicit parameter in protocols, and do not explicitly write it.

\subsection{Analysis in the AGM model}\label{subsec:AGM}
For security analysis we will use the Algebraic Group Model of Fuchsbauer, Kiltz and Loss \cite{AGM}.
In our protocols, by an \emph{algebraic adversary} \adv in an SRS-based protocol we mean a \poly-time algorithm which satisfies the following.
\begin{itemize}
 \item For $i\in \set{1,2}$, whenever \adv outputs an element $A\in \Gi$, it also outputs a vector $v$ over \F such that $A = <v,\srsi>$.
\end{itemize}

\paragraph{Idealized verifier checks for algebraic adversaries}
We introduce some terminology to capture the advantage of analysis in the AGM.

First we say our \srs0 \emph{has degree $Q$} if all elements of \srsi are of the form  \enci{f(x)} for $f\in \polysofdeg{Q}$ and uniform $x\in \F$. In the following discussion let us assume we are executing a protocol with a degree $Q$ SRS, and denote by $f_{i,j}$ the corresponding polynomial for the $j$'th element of \srsi.

Denote by $a,b$ the vectors of $\F$-elements whose encodings in $\G1,\G2$ an algebraic adversary \adv outputs during a protocol execution; e.g., the $j$'th $\G1$ element output by \adv is \enc1{a_j}.

By a ``real pairing check'' we mean a check of the form
\[(a\cdot T_1) \cdot (T_2\cdot b)=0\]
for some matrices $T_1,T_2$ over $\F$.
Note that such a check can indeed be done efficiently given the encoded elements and the pairing function $e:\G1\times \G2\to \Gt$.



Given such a ``real pairing check'', and the adversary \adv and protocol execution during which the elements were output, define the corresponding ``ideal check'' as follows.
Since \adv is algebraic when he outputs \enci{a_j} he also outputs a vector $v$ such that, from linearity, $a_j = \sum v_\ell f_{i,\ell}(x)=R_{i,j}(x)$ for $R_{i,j}(X) \defeq \sum v_\ell f_{i,\ell}(X)$.
Denote, for $i\in \set{1,2}$ the vector of polynomials $R_i=(R_{i,j})_j$.
The corresponding ideal check, checks as a polynomial identity whether
\[(R_1 \cdot T_1)\cdot (T_2\cdot R_2) \equiv 0\]


The following lemma is inspired by \cite{AGM}'s analysis of \cite{groth16},
and tells us that for soundness analysis against algebraic adversaries it suffices to look at ideal checks.
Before stating the lemma we define the $Q$-DLOG assumption similarly to \cite{AGM}.
\begin{dfn}\label{ref:qdlog}
 Fix an integer $Q$. The \emph{$Q$-DLOG assumption for $(\G1,\G2)$} states that given
 \[\enc1{1},\enc1{x},\ldots,\enc1{x^Q},\enc2{1},\enc2{x},\ldots,\enc2{x^Q}\]
 for uniformly chosen $x\in \F$, the probability of an efficient \adv outputting $x$
 is \negl.
\end{dfn}


The following lemma is proved in \cite{plonk}-based on the arguments of \cite{AGM}.
\begin{lemma}\label{lem:AGManalysis}
Assume the $Q$-DLOG for $(\G1,\G2)$.
 Given an algebraic adversary \adv participating in a protocol with a degree $Q$ SRS,
 the probability of any real pairing check passing is larger by at most an additive \negl factor than the probability the corresponding ideal check holds.
\end{lemma}


\paragraph{Knowlege soundness in the Algebraic Group Model}
We say a protocol \prot between a prover \prv and verifier \ver for a relation \rel has \emph{Knowledge Soundness in the Algebraic Group Model} if there exists an efficient \ext such that
the probability of any algebraic adversary \adv winning the following game is \negl.

\begin{enumerate}
 \item \adv chooses input \inp and plays the role of \prv in \prot with input \inp.
 \item \ext given access to all of \adv's messages during the protocol (including the coefficients of the linear combinations) outputs \wit.
 \item \adv wins if
 \begin{enumerate}
  \item \ver outputs \acc at the end of the protocol, and
  \item $(\inp,\wit)\notin \rel$.
 \end{enumerate}

\end{enumerate}

\subsection{Polynomial commitment schemes}\label{subsec:PCS}
We define polynomial commitment schemes similarly to \cite{plonk}.
Specifically, we define the \open procedure in a batched setting having multiple polynomials and evaluation points.
In the context of multiple points, it will be more convenient to assume the alleged evaluation points 
of a polynomial $f$ on a set $S\subset \F$  are given as a \emph{polynomial} $r\in \polysofdeg{|S|}$ with
$r(z)=f(z)$ for each $z\in S$. Under this convention, the condition that the evaluations are correct; i.e. $r(z)=f(z)$ for each $z\in S$, is equivalent to $f(X)-r(X)$ being divisble by $Z_S(X)$;
where $Z_S(X)\defeq \prod_{z\in S} (X-z)$.

\begin{dfn}\label{dfn:PCscheme}
A polynomial commitment scheme is a triplet $\PCscheme = (\gen,\com,\open)$ such that
\begin{itemize}
 \item $\gen(d)$ -  is a randomized algorithm that given positive integer $d$ outputs a structured reference string (SRS) \srs0.
 \item $\com(f,\srs0)$ - is an algorithm that given a polynomial $f\in \polysofdeg{d}$ and an output \srs0 of $\gen(d)$  returns a commitment \cm to $f$.
 \item \open is a public coin protocol between parties \prvpc and \verpc. \prvpc is given $ f_1,\ldots,f_k \in \polysofdeg{d}$. \prvpc and \verpc are both given

 \begin{enumerate}
  \item  positive integers $d,t=\poly$,
  \item  $\srs0=\gen(d)$,
  \item a subset $T=\set{z_1,\ldots,z_t}\subset \F$,
  \item subsets $S_1,\ldots,S_k \subset T$,
  \item $\cm_1,\ldots,\cm_k$ - the alleged commitments to $f_1,\ldots,f_k$,
  \item \sett{r_i\in \polysofdeg{|S_i|}}{i\in [k]} - the polynomials describing the alleged correct openings, i.e. having  $r_i(z)=f_i(z)$ for each $i\in [k], z\in S_i$.
 \end{enumerate}
 At the end of the protocol \verpc outputs \acc or \rej;
such that
\begin{itemize}
 \item \textbf{Completeness:} Fix any $k,t=\poly$, $T=\set{z_1,\ldots,z_t}\subset \F$, $S_1,\ldots,S_k \subset T$, $f_1,\ldots,f_k\in \polysofdeg{d},\sett{r_i\in \polysofdeg{|S_i|}}{i\in [k]}$. Suppose that for each $i\in [k]$, $\cm_i = \com(f_i,\srs0)$, and for each $i\in [k]$ we have  $Z_{S_i}|(f_i-r_i)$.  Then if \prvpc follows \open correctly with these values, \verpc outputs \acc with probability one.
 \item \textbf{Knowledge soundness in the algebraic group model:} There exists an efficient \ext such that for any algebraic adversary \adv and any choice of $d=\poly$ the probability of \adv winning the following game is \negl over the randomness of \adv, \verpc and \gen.
 \begin{enumerate}
  \item Given $d$ and $\srs0=\gen(d)$, \adv outputs $\cm_1,\ldots,\cm_k\in \G1$.
  \item \ext, given access to the messages of \adv during the previous step, outputs $f_1,\ldots,f_k \in \polysofdeg{d}$.
  \item \adv outputs $T=\set{z_1,\ldots,z_t}\subset \F$, $S_1,\ldots,S_k \subset T, \sett{r_i\in \polysofdeg{|S_i|}}{i\in [k]}$.
  \item \adv takes the part of \prvpc in the protocol \open with the inputs
  $\cm_1,\ldots,\cm_k$, $T, S_1,\ldots,S_k,$  $\set{r_i}$.
  \item $\adv$ wins if
  \begin{itemize}
   \item \verpc outputs \acc at the end of the protocol.
   \item For some $i\in [k]$, $Z_{S_i}\nmid (f_i-r_i)$.
  \end{itemize}

 \end{enumerate}

\end{itemize}
\end{itemize}
\end{dfn}


\section{Our first scheme}\label{sec:main}



% It is in fact a slightly simpler scheme than in \cite{sonic} because, as explained in the introduction, there is no need to deal with holes in the allowed range of degrees.
We first state the following straightforward claim that will allow us to efficiently ``uniformize'' checks on different evaluation points.
\begin{claim}\label{clm:div}
 Fix subsets $S\subset T\subset \F$, and a polynomial $g \in \polysofdeg{d}$.
 Then $Z_S(X)$ divides $g(X)$ if and only if $Z_T(X)$ divides $Z_{T\setminus S}(X)\cdot g(X)$.
\end{claim}



% \begin{proof}
%  $Z_T$ divides $Z_{T\setminus S}\cdot (f(X)-r(X))$ if and only if
%  $Z_{T\setminus S}\cdot (f(X)-r(X))$ vanishes on $T$ if and only if
%  $(f(X)-r(X))$ vanishes on $S$.
% \end{proof}



We also use the following claim, which is part of Claim 4.6 in \cite{plonk} where a proof of it can be found.
\begin{claim}\label{clm:div_sum}
 Fix $F_1,\ldots,F_k \in \polysofdeg{n}$. Fix $Z\in \polysofdeg{n}$ that decomposes to distinct linear factors over \F.
 Suppose that for some $i\in [k]$, $Z\nmid F_i$.
 Then, e.w.p $k/|\F|$ over uniform $\gamma\in \F$, $Z$ does not divide
 \[G\defeq \sum_{j=1}^k \gamma ^{j-1} \cdot F_j.\]

\end{claim}




\begin{enumerate}
 \item $\gen(d)$ - choose uniform $x\in \F$. Output $\srs0 =(\enc1{1},\enc1{x},\ldots,\enc1{x^{d-1}},\enc2{1},\enc2{x},\ldots,\enc2{x^t})$.
 \item $\com(f,\srs0) \defeq \enc1{f(x)}$.
 \item
 \noindent
 $\open\left(d,t,\sett{\cm_i}{i\in [k]},T=\set{z_1,\ldots,z_t}\subset \F,\sett{S_i\subset T}{i\in [k]},\sett{r_{i}}{i\in [k]}\right)$:
 \begin{enumerate}
  \item \verpc sends a random $\gamma\in \F$.
%   \item For $i\in [k]$, \verpc and \prvpc both compute the polynomials \sett{r_i}{i\in [k]}
%   such that $r_i\in \polysofdeg{|S_i|}$ satisfies $r_i(z) = s_{i,z}$ for each $z\in S_i$.
 \item \prvpc computes the polynomial
 \[h(X)\defeq \sum_{i\in [k]} \gamma^{i-1}\cdot \frac{f_i(X)-r_i(X)}{Z_{S_i(X)}}  \]
 and using \srs0 computes and sends $W\defeq \enc1{h(x)}$.
% \[]
 \item\label{step:computeW} \verpc computes for each $i\in [k]$, $Z_i \defeq \enc2{Z_{T\setminus S_i}(x)}$.
 \item \verpc computes
 \[F\defeq \sum_{i\in [k]} \gamma^{i-1} \cdot e(\cm_i-\enc1{r_i(x)}, Z_i).\]
 \item \verpc outputs \acc if and only if
 \[ F = e(W,\enc2{Z_T(x)}).\]
 \end{enumerate}

 We argue knowledge soundness for the above protocol. More precisely, we argue the existence of an efficient \ext such that an algebraic adversary \adv can only win the KS game described in Section \ref{subsec:PCS} w.p. \negl.
 %when restricting itself to choosing $z=z_1=\ldots=z_t$.


 Let \adv be such an algebraic adversary.

 \adv begins by outputting $\cm_1,\ldots,\cm_k\in \G1$.
 Each $\cm_i$ is a linear combination $\sum_{j=0}^{d-1} a_{i,j} \enc1{x^j}$.
 \ext, who is given the coefficients \set{a_{i,j}}, simply outputs the polynomials
 \[f_i(X)\defeq \sum_{j=0}^{d-1} a_{i,j} \cdot X^j.\]
 \adv now outputs $T=\set{z_1,\ldots,z_t}\subset \F,\sett{S_i\subset T}{i\in [k]},\sett{r_{i}}{i\in [k]}$.
  Assume that for some $i^*\in [k],$, we have $Z_{S_{i^*}}\nmid (f_{i^*}- r_{i^*})$. We show that for any strategy of \adv from this point, \verpoly outputs \acc w.p. \negl.

 In the first step of \open, \verpoly chooses a random $\gamma \in \F$.
 Let
 \[f(X)\defeq \sum_{i\in [t]} \gamma^{i-1} \cdot Z_{T\setminus S_i}(X)\cdot (f_i(X)-r_i(X)).\]
 We know from Claim \ref{clm:div} that $F_{i^*} \defeq  Z_{T\setminus S_{i^*}}\cdot (f_{i^*}-r_{i^*})$ is not divisible by $Z_T$. Thus, using Claim \ref{clm:div_sum}, we know that e.w.p $k/|\F|$ over $\gamma$, $f$ is not divisble by $Z_T$.
  Now \adv outputs $W=\enc1{H(x)}$ for some $H\in\polysofdeg{d}$.
 According to Lemma \ref{lem:AGManalysis}, it suffices to upper bound the probability that the ideal check corresponding to the real pairing check in the protocol passes. It has the form
 \[f(X) \equiv H(X)Z_T(X).\]
 The check passing implies that
 $f(X)$ is divisible by $Z_T$. Thus the ideal check can only pass w.p. $k/|\F|= \negl$ over the randomness of \verpoly, which implies the same thing for the real check according to Lemma \ref{lem:AGManalysis}.


 \end{enumerate}



 We summarize the efficiency properties of the scheme.

 \begin{lemma}\label{lem:multikate}
  There is a PCS $\PCscheme=(\gen,\com,\open)$ such that
  \begin{enumerate}
\item For positive integer $d$ $\srs0=\gen(d)$ consists of $d+1$ \G1 elements and $t+1$ \G2 elements.
  \item For integer $n\leq d$ and $f\in \polysofdeg{n}$, computing $\com(f,\srs0)$ when $\srs0=\gen(d)$ requires $n$ \G1-exponentiations.
   \item Given $T \defeq (z_1,\ldots,z_t)\in \F^t, f_1,\ldots, f_k \in \polysofdeg{d}, \sett{S_i}{i\in [k]}$, denote by $k^*$ the number of distinct subsets  \set{S^*_1,\ldots,S^*_{k^*}} in \set{S_i}; and
   let $K\defeq t+ \sumi {k^*}\left( t-|S^*_i|\right)$.
   and denote $n \defeq \max\sett{\deg(f_i)}{i\in [k]}$.
   Let $\cm_i = \com(f_i)$.
   Then $\open\left(\set{\cm_i},\set{f_i},T,\set{S_i\subset T},\set{r_i},\srs0 \right)$ requires
   \begin{enumerate}
    \item A single \G1 element to be passed from \prvpoly to \verpoly.
    \item At most $n$ \G1-exponentiations of \prvpoly.
    \item $k-1$ \G1-exponentiations, $K$ \G2-exponentiations and $k^*+1$ pairings of \verpoly.
   \end{enumerate}
\end{enumerate}

\end{lemma}

\newpage
\section{Reducing verifier operations at the expense of proof length}\label{sec:secondpcs}

We describe a variant of the scheme of Section \ref{sec:main} where we eliminate the verifier's \G2 operations and reduce the number of pairings to two. This comes at the cost of an extra \G1 element sent by the prover. Roughly speaking, while in Section \ref{sec:main} \verpc used \G2 and pairing operations to compute the evaluation of a certain polynomial $f$ encoded in the target group, in this protocol \prvpc gives \verpc this evaluation encoded \G1, accompanied by a proof that it is correct (which is the second \G1 element sent by \prvpc).
We state the result first, followed by the description of the scheme.

\begin{lemma}\label{lem:multikateG1}
There is a PCS $\PCscheme=(\gen,\com,\open)$ such that
  \begin{enumerate}
\item For positive integer $d$, $\srs0=\gen(d)$ consists of $d+1$ \G1 elements and $2$ \G2 elements.
  \item For integer $n\leq d$ and $f\in \polysofdeg{n}$, computing $\com(f,\srs0)$ when $\srs0=\gen(d)$ requires $n$ \G1-exponentiations.
   \item Given $T \defeq (z_1,\ldots,z_t)\in \F^t, f_1,\ldots, f_k \in \polysofdeg{d}, \sett{S_i}{i\in [k]}$   and denote $n \defeq \max\sett{\deg(f_i)}{i\in [k]}$.
   Let $\cm_i = \com(f_i)$.
   Then $\open\left(\set{\cm_i},\set{f_i},T,\set{S_i\subset T},\set{r_i},\srs0 \right)$ requires

    \begin{enumerate}
    \item 2 \G1 elements sent from \prvpc to \verpc.
    \item at most $2n+1$ \G1-exponentiations of \prvpc.
    \item $k+3$ \G1-exponentiations and 2 pairings of \verpc.
\end{enumerate}
\end{enumerate}


\end{lemma}

\noindent The PCS is described below.

\begin{enumerate}
\item $\gen(d)$ outputs $\srs0 =(\enc1{1},\enc1{x},\ldots,\enc1{x^{d-1}},\enc2{1},\enc2{x})$ for a random $x\in \F$
\item $\com(f_i)=\enc1{f_i(x)}$
\item We describe the \open procedure twice below. First, in a way that will be convenient for the security analysis, and later in an equivalent more concise way that also optimized verifier operations.
\end{enumerate}

\noindent
$\open(d,\set{\com(f_i)},\set{S_i},\set{r_i})$:
\begin{enumerate}
 \item \verpc sends random $\gamma\in \F$.	    \[f(X)=\sum_{i\in [k]} \gamma^{i-1} Z_{T\setminus S_i}(X)(f_i(X)-r_i(X))\]
  \item For $i\in [k]$, \verpc and \prvpc both compute the polynomials \sett{r_i}{i\in [k]}
  \item \verpc sends a random evaluation point $z\in \F$
  such that $r_i\in \polysofdeg{|S_i|}$ satisfies $r_i(z) = s_{i,z}$ for each $z\in S_i$. 
  \item \prvpc sends $W'=\enc1{f'(x)/(x-z)}$ where
 \item \prvpc computes the polynomial	    \[f'(X)=\sum_{i\in [k]} \gamma^{i-1} Z_{T\setminus S_i}(z)(f_i(X)-r_i(z)) - Z_T(z)(f/Z_T)(X)\]
 \[f(X)\defeq \sum_{i=1}^t \gamma^{i-1}\cdot Z_{T\setminus S_i}(X)\cdot (f_i(X)-r_i(X)).\]	    
 \item \verpc checks $e(F-zW',\enc2{1}) = e(W',\enc2{x})$ where
 Recall that $f$ is divisible by $Z_T$ according to Claim \ref{clm:div_sum}, and define
 \[F=\sum_{i\in [k]} \gamma^{i-1} Z_{T\setminus S_i}(z)\com(f_i) - \enc1{\sum_{i\in [k]} \gamma^{i-1} Z_{T\setminus S_i}(z)r_i(z)} - Z_T(z)W\]
 $h(X)\defeq f(X)/Z_T(X)$.	    
 Using \srs0, \prvpc computes and sends $W\defeq \enc1{h(x)}$.	
% \[]	
 \item \verpc sends random $z\in \F$.	
%  \item Let $S'_1,\ldots S'_{k^*}$ be the distinct subsets among $S_1,\ldots,S_k$. ``Split'' $g$ according to these distinct subsets; i.e. for $i\in [k^*]$	
%  \[g_i(X) \defeq \sum_{j\in [k], S_j=S'_i}^t \gamma^{j-1}\cdot Z_{T\setminus S_j}(X)\cdot (f_j(X)-r_j(X)).  \]	
%  Note that $g(X)=\sum_{i\in [k^*]} g_i(X)$.	
%  	
%  \prvpc sends the values $t_i \defeq g_i(z)$ for $i\in [k^*]$.	

\item \prvpc computes the polynomial	
\[L(X)\defeq f_z(X) - Z_T(z)\cdot h(X),\]	
where 	
\[f_z(X)\defeq \sum_{i=1}^t \gamma^{i-1}\cdot Z_{T\setminus S_i}(z)\cdot (f_i(X)-r_i(X))\]	
Note that $L(z)= f(z)- Z_T(z)\cdot h(z) =0$, and thus $(X-z)$ divides $L$.	
\prvpc sends $W'\defeq \enc1{\frac{L(x)}{x-z}}$.	

\item \verpc computes:	
\[F\defeq \sum_{i\in [t]} \gamma^{i-1} \cdot Z_{T\setminus S_i}(z)\cdot (\com(f_i) - \enc1{r_i(X)}) - Z_T(z)\cdot W \]	
 \item \verpc outputs \acc if and only if	
 \[ e(F,\enc2{1}) = e(W',\enc2{x-z}).\]	
\end{enumerate}

    
    


%\newpage
We begin by observing that the protocol is well-defined for the honest prover:
$W$ in step \ref{stp:W} is well-defined since $Z_t\mid f$ by Claim \ref{clm:div_sum}. Similarly, since $f_z(z)=f(z)-Z_T(z)(f/Z_T)(z)=0$, $f'$ is divisible by $X-z$. Thus,
$W'$ in step \ref{step:W'} is well-defined.

   



We argue knowledge soundness for the above protocol. More precisely, we argue the existence of an efficient \ext such that an algebraic adversary \adv can only win the KS game w.p. \negl.  The proof begins identically to the previous one.
 %when restricting itself to choosing $z=z_1=\ldots=z_t$.


 Let \adv be such an algebraic adversary.

 \adv begins by outputting $\cm_1,\ldots,\cm_k\in \G1$.
 Each $\cm_i$ is a linear combination $\sum_{j=0}^{d-1} a_{i,j} \enc1{x^j}$.
 \ext, who is given the coefficients \set{a_{i,j}}, simply outputs the polynomials
 \[f_i(X)\defeq \sum_{j=0}^{d-1} a_{i,j} \cdot X^j.\]
 \adv now outputs $T=\set{z_1,\ldots,z_t}\subset \F,\sett{S_i\subset T}{i\in [k]},\sett{r_{i}}{i\in [k]}$.
  Assume that for some $i^*\in [k]$, we have $Z_{S_{i^*}}\nmid (f_{i^*}-r_{i^*})$. We show that for any strategy of \adv from this point, \verpoly outputs \acc w.p. \negl.

 In the first step of \open, \verpoly chooses a random $\gamma \in \F$.
 Let
 \[f(X)\defeq \sum_{i\in [t]} \gamma^{i-1} \cdot Z_{T\setminus S_i}\cdot (f_i(X)-r_i(X)).\]
 We know from Claim \ref{clm:div} that $F_{i^*} \defeq  Z_{T\setminus S_{i^*}}\cdot (f_{i^*}-r_{i^*})$ is not divisible by $Z_T$. Thus, using Claim \ref{clm:div_sum}, we know that e.w.p $k/|\F|$ over $\gamma$, $f$ is not divisble by $Z_T$. Assume we are in this case.  Now \adv outputs $W=\enc1{H(x)}$ for some $H\in\polysofdeg{d}$, followed by \verpc sending uniform $z\in \F$.
 Since we are in the case that $f$ is not divisble by $Z_T$, we know there are at most
 $2d$ values $z\in \F$ such that $f(z) = H(z)\cdot Z_T(z)$; and thus $z$ chosen by \verpc is of this form only w.p. \negl. Assume we are in the case that $z$ sent by \verpc is not of this form.
  \prvpc now outputs $W'=\enc1{H'(x)}$ for some $H'\in \polysofdeg{d}$
 According to Lemma \ref{lem:AGManalysis}, it suffices to upper bound the probability that the ideal check corresponding to the real pairing check in the protocol passes.
 Denoting
 \[L'(X)\defeq \sum_{i\in [t]} Z_{T\setminus S_i}(z)\cdot (f_i(X) - r_i(z)) - Z_T(z)\cdot H(X),\]
 the ideal check has the form
 \[L'(X)\equiv H'(X)\cdot (X-z),\]
 and thus can pass for some $H'\in \polysofdeg{d}$ only if $L'$ is divisible by $(X-z)$, which means $L'(z)=0$.
 However
 \[L'(z) = \sum_{i\in [t]} Z_{T\setminus S_i}(z)\cdot (f_i(z) - r_i(z)) - Z_T(z)\cdot H(z)=
  f(z)-Z_T(z)\cdot H(z),
 \]
and we are in the case where $f(z)\neq Z_T(z)\cdot H(z)$.
 In summary, the ideal check can only pass w.p. $\negl$ over the randomness of \verpc, which implies the same thing for the real check according to Lemma \ref{lem:AGManalysis}.


 
 \subsection*{The \open procedure, ``cleaned up'' and optimized}
 
     \begin{enumerate}
    \item \verpc sends a random challenge $\gamma\in \F$
    \item\label{stp:W} \prvpc sends $W\defeq \enc1{(f/Z_T)(x)}$ where
    \[f(X)\defeq \sum_{i\in [k]} \gamma^{i-1}\cdot  Z_{T\setminus S_i}(X)(f_i(X)-r_i(X)).\]
    \item \verpc sends a random evaluation point $z\in \F$
    \item\label{step:W'} \prvpc sends $W'\defeq \enc1{(f_z/(X-z))(x)}$ where
    \[f_z(X)\defeq \sum_{i\in [k]} \gamma^{i-1}Z_{T\setminus S_i}(z)\cdot (f_i(X)-r_i(z)) - Z_T(z)\cdot (f/Z_T)(X).\]
%     \[f'(X)\defeq \sum_{i\in [k]} \gamma^{i-1}\cdot  Z_{T\setminus S_i}(z)(f_i(X)-r_i(z)) - Z_T(z)(f/Z_T)(X).\]
    \item \verpc computes
     \[F\defeq \sum_{i\in [k]} \gamma^{i-1}  Z_{T\setminus S_i}(z)\cdot \cm_i - \enc1{\sum_{i\in [k]} \gamma^{i-1} Z_{T\setminus S_i}(z)r_i(z)} - Z_T(z)W.\]
%      \[F\defeq \sum_{i\in [k]} \gamma^{i-1}  Z_{T\setminus S_i}(z)\cdot (\cm_i - \enc1{r_i(z)}) - Z_T(z)W.\]
    \item \verpc outputs \acc iff $e(F-zW',\enc2{1}) = e(W',\enc2{x})$.
    \end{enumerate}


\section*{Acknowledgements}
Part of this research was conducted while the second author was supported by Protocol Labs.
\bibliographystyle{alpha}
\bibliography{references}

\end{document}


